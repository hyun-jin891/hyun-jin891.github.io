---
layout: post
title: Graph
description: >
  Data Structure
tags: [graph]
use_math: true
categories:
  - study
  - computer science
---
### BFS
* **Breadth First Search** for graph<br>
* can be used for the shortest distance<br>
![그림1](/assets/img/63.PNG?raw=true){: width="600" height="600"}

### Implementation
* by queue
  * FIFO (First in, First Out)
  * **deque** (bidirectional queue) : efficient
  ~~~python
  from collections import deque
  q = deque()
  q.append(1)  # [1]
  q.append(2)  # [1, 2]
  q.popleft()  # [2]
  ~~~
* Procedure
  1. node → queue
  2. A node escapes from queue
  3. This node is marked "visited"
  4. All adjacent nodes of this node are processed by first step simultaneously (repeating)<br>
  ![그림2](/assets/img/64.PNG?raw=true){: width="600" height="600"}
  ![그림3](/assets/img/65.PNG?raw=true){: width="600" height="600"}
  ![그림4](/assets/img/66.PNG?raw=true){: width="600" height="600"}
  ![그림5](/assets/img/67.PNG?raw=true){: width="600" height="600"}
  ![그림6](/assets/img/68.PNG?raw=true){: width="600" height="600"}
  ![그림7](/assets/img/69.PNG?raw=true){: width="600" height="600"}

* Mark "visited"
  * example 1
  ~~~python
  # graph == 2D array (case providing 2D information directly)

  graph[i][j] = 0 # originally 1
  ~~~
  * example 2
  ~~~python
  visited = []
  visited.append(/*specific node*/)
  if node not in visited:
    # statement
  ~~~

### Pseudocode
~~~python
from collections import deque

def BFS(graph, start_node):
  visited = []
  need_visit = deque()
  need_visit.append(start_node)

  while need_visit:
    node = need_visit.popleft()
    visited.append(node)

    ## movement toward adjacent nodes of the node
    if adjacent_node not in visited:
      need_visit.append(adjacent_node)
~~~
